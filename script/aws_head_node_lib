#!/bin/bash
#####################################################################
##                                                                 ##
##  This script is used for uploading data + config to AWS cloud.  ##
##                                                                 ##
#####################################################################

# Add job definition to Nextflow Config
# Param 1 - Nextflow label
# Param 2 - Nextflow container
add_nextflow_job_def() {
	aws_log "Add Nextflow Docker job-definition label=${1}, container=${2}"
	echo "    withLabel: '${1}' {" >> "$(local_nf_conf)"
	echo "        container = '${2}'" >> "$(local_nf_conf)"
	echo "    }" >> "$(local_nf_conf)"
}

# Build Docker Job defs to use with label references in Nextflow main.nf
build_docker_job_defs() {
	refresh_aws_cache
	[ -f "$(get_docker_job_def_flag)" ] && aws_log "Jobs already exist, found flag file: $(get_docker_job_def_flag)" && return
	init_nextflow_config
	dockerModules=$(docker search --no-trunc --limit 100 ${dockerUser} | grep -E ^${dockerUser} ) 
	IFS2=$IFS && IFS=$'\t'
	[ ${#dockerModules} -eq 0 ] && aws_log "No Docker images found for Docker Account \"${dockerUser}\"" && return
	aws_log "Building Docker job-definitions..."
	echo ${dockerModules} | while read -r line; do
		[ $(echo $line | grep -c blj_basic) -gt 0 ] && aws_log "Skip Docker image: \"$line\"" && continue
		module=$(echo $line | cut -f 1 -d " ")
		jobImg="${module}:${dockerImgVersion}"
		aws_log "Add job-definition for Docker image: \"$jobImg\""
		jobLabel=${jobImg/\//_} 
		jobLabel=${jobLabel/:/_} 
	    jobConfig="{ 
			\"image\": \"${jobImg}\",
			\"vcpus\": 2,
			\"memory\": 1024,
			\"command\": [ \"/bin/bash\" ],
			\"jobRoleArn\": \"$(get_stack_param ECSTaskRole)\",
			\"volumes\": [ { \"host\": { \"sourcePath\": \"${EFS}\" }, \"name\": \"efs\" }, { \"host\": { \"sourcePath\": \"${EC2_HOME}\" }, \"name\": \"ec2Home\" } ],
			\"mountPoints\": [ { \"containerPath\": \"${EFS}\", \"readOnly\": false, \"sourceVolume\": \"efs\" }, { \"containerPath\": \"${EC2_HOME}\", \"readOnly\": false, \"sourceVolume\": \"ec2Home\" } ],
			\"readonlyRootFilesystem\": false,
			\"privileged\": true
		}"
		jobDef="${awsStack}_${jobLabel}"
		jobName=$(aws batch describe-job-definitions --status ACTIVE --job-definition-name ${jobDef} --query "jobDefinitions[*].jobDefinitionName")
		if [ ${#jobName} -eq 0 ]; then
			registeredJob=$(aws batch register-job-definition --job-definition-name $jobDef --type container --container-properties "${jobConfig}")
			aws_log "Registered new Docker job-definition: ${registeredJob}"
			jobName=$(echo $registeredJob | grep job-definition | sed 's/^.*job-definition/job-definition:\//' | awk '//{print $1}' )
			[ ${#jobName} -eq 0 ] && exit_script "Error [ aws_head_node_lib.build_docker_job_defs() ]: Failed to register job-definition: ${jobDef}"
			aws_log "Docker job-definition name: ${jobName}"
		else
			aws_log "Found existing Docker job-definition: ${jobName}"
		fi
		add_nextflow_job_def "image_${jobLabel}" "${jobName}"
	done
	IFS2=$IFS
	close_nextflow_config
	touch $(get_docker_job_def_flag)
}

# Close Nextflow Config process block
close_nextflow_config() {
	echo "}" >> "$(local_nf_conf)"
	echo "" >> "$(local_nf_conf)"
}

# Connect to running head node
connect_head() {
	aws_log "Opening SSH tunnel to Head Node...$(get_ec2_public_ip)"
	ssh -o StrictHostKeyChecking=no -i $(key_file) ${EC2_USER}@$(get_ec2_public_ip)
}

# Download reports from AWS
# Param 1 - Pipeline directory name
aws_dl_reports() {
	aws_log "Opening SSH tunnel to Head Node...$(get_ec2_public_ip)"
	scp -pro StrictHostKeyChecking=no -i $(key_file) ${EC2_USER}@$(get_ec2_public_ip):${EFS}/pipelines/${1} ${pipelineDownloadDir}
}

# Get the flag file that indicates Docker job definitions were created
get_docker_job_def_flag() {
	echo "${HOME}/.${awsStack}-CREATED_DOCKER_JOB_DEFS"
}

# Get EC2 instance public IP address
get_ec2_public_ip() {
	if [ ${#ec2PublicIP} -eq 0 ]; then 
		ec2PublicIP=$(aws ec2 describe-instances --instance-ids ${awsEc2InstanceID} --query "Reservations[].Instances[].PublicDnsName")
		set_blj_prop ec2PublicIP $ec2PublicIP
	fi
	echo $ec2PublicIP
}

# Get a stack parameter for the configured stack 
# Param 1 - Param name
get_stack_param() {
	myParam=$(aws cloudformation describe-stacks --stack-name "${awsStack}" --query "Stacks[*].Outputs[?OutputKey=='$1'].OutputValue")
	[ ${#myParam} -eq 0 ] && return
	echo "${myParam}"
}

# Create the basic nextflow config file using the current statck AWS batch queues
init_nextflow_config() {
	echo "// Nextflow properties inherited by BioLockJ $(biolockj -v) pipeline main.nf" > "$(local_nf_conf)"
	echo "" >> "$(local_nf_conf)"
	echo "executor {" >> "$(local_nf_conf)"
    echo "    name = 'awsbatch'" >> "$(local_nf_conf)"
    echo "    executor.awscli = '${EC2_HOME}/miniconda/bin/aws'" >> "$(local_nf_conf)"
    echo "}" >> "$(local_nf_conf)"
    echo "" >> "$(local_nf_conf)"
    echo "aws {" >> "$(local_nf_conf)"
	echo "    region = '${awsRegion}'" >> "$(local_nf_conf)"
	echo "}" >> "$(local_nf_conf)"
	echo "" >> "$(local_nf_conf)"
	echo "process {" >> "$(local_nf_conf)"
	echo "    queue = '$(get_stack_param LowPriorityJobQueue)'" >> "$(local_nf_conf)"
	echo "    withLabel: 'DEMAND' {" >> "$(local_nf_conf)"
	echo "        queue = '$(get_stack_param HighPriorityJobQueue)'" >> "$(local_nf_conf)"
	echo "    }" >> "$(local_nf_conf)"
}

# Launch a new ec2 head node
# Param 1 (optional) - If "start" then launch the pipeline, otherwise connect to the head node
# Param 2 (optional) - Flag to use existing AWS Cloud
launch_ec2_head_node() {
	[ -x "$(which docker)" ] && build_docker_job_defs
	if [ $# -lt 2 ]; then
		cache_key_pair
		set_ec2_head_node_id
		refresh_aws_cache
		keyFound=$(cat ~/.ssh/known_hosts | grep -c $(get_ec2_public_ip))
		[ ${keyFound} -gt 0 ] && ssh-keygen -f ~/.ssh/known_hosts -R $(get_ec2_public_ip)
	else
		aws_log "Run pipeline on existing EC2 head node"
	fi
	stage_pipeline_on_aws ${2}
	if [ $# -eq 1 ] && [ "${1}" == "start" ] && [ -x "$(which docker)" ] || [ $# -eq 2 ]; then
		aws_log "Exectue Remote CMD [  nohup ${EC2_HOME}/$(basename $(start_aws_pipeline_script)) >/dev/null 2>&1 & ]"
		exe_remote_cmd "nohup ${EC2_HOME}/$(basename $(start_aws_pipeline_script)) >/dev/null 2>&1 &" 
	fi
	aws_log "Exectue CMD [  connect_head  ]"
	connect_head
}

# Start Head node if stopped, create if not found, and set awsEc2InstanceID
set_ec2_head_node_id() {
	refresh_aws_cache
	isStarting=false
	[ "${#awsEc2InstanceID}" -gt 0 ] && instances=$(aws ec2 describe-instances --instance-ids "${awsEc2InstanceID}" --query "Reservations[].Instances[].[State.Name, InstanceId]")
	if [ "${instances/$awsEc2InstanceID}" != "${awsEc2InstanceID}" ]; then
		aws_log "Found existing instance ${awsEc2InstanceID}"
		if [ "${instances/stopped}" != "${instances}" ]; then
			printf "Configured EC2 instance ${awsEc2InstanceID} was stopped...attempting to restart...please wait."
			aws ec2 start-instances --instance-ids "${awsEc2InstanceID}"
		elif [ "${instances/terminated}" != "${instances}" ]; then
			aws_log "Configured EC2 instance ${awsEc2InstanceID} was terminated...launching a new instance"
		elif [ "${instances/pending}" != "${instances}" ] || [ "${instances/shutting-down}" != "${awsEc2InstanceID}" ] || [ "${instances/stopping}" != "${awsEc2InstanceID}" ]; then
			exit_script "Error [ aws_head_node_lib.set_ec2_head_node_id() ]: Configured EC2 Instance ${awsEc2InstanceID} has an in-between state-status, aborting launch EC2 instance - check status and try again later: ${instances}"
		elif [ "${instances/running}" != "${instances}" ]; then
			aws_log "Configured EC2 instance ${awsEc2InstanceID} is running..." && return
		fi
	fi
	
	runTime=0
	if [ $isStarting == false ]; then 
		secureGroup="$(get_stack_param BastionSecurityGroup)"
		subnet="$(get_stack_param Subnet1)"
		templateId="$(get_stack_param HeadNodeLaunchTemplateId)"
		if [ ${#awsAmi} -eq 0 ] || [ ${#awsStack} -eq 0 ] || [ ${#secureGroup} -eq 0 ] || [ ${#subnet} -eq 0 ] || [ ${#templateId} -eq 0 ]; then
			exit_script "Error [ aws_head_node_lib.set_ec2_head_node_id() ]: Cannot launch EC2 - required parameters undefined in $blj_aws_config"
		fi
		
		ec2Name="Head-${awsStack}" 
		awsEc2InstanceID=$(aws ec2 run-instances --count 1 --key-name ${awsStack} --image-id ${awsAmi} --security-group-ids ${secureGroup} \
			--tag-specifications "ResourceType=instance,Tags={Key=Name,Value='${ec2Name}'}" --subnet-id ${subnet} \
			--launch-template LaunchTemplateId=${templateId} --instance-type "${awsEc2InstanceType}" --query "Instances[].InstanceId" )
		printf "Launching EC2 Instance, please wait."
	fi
	systemStatus=init  
	while [ "$systemStatus" != "ok" ]; do
		systemStatus=$(aws ec2 describe-instance-status --instance-ids ${awsEc2InstanceID} --query "InstanceStatuses[*].SystemStatus.Status")
		printf "."
		sleep 10s
		runTime=$((runTime+10))  
	done
	echo ""
	aws_log "EC2 Instance [ ID=${awsEc2InstanceID} ] created in $runTime seconds"
	set_blj_prop awsEc2InstanceID ${awsEc2InstanceID}
	
	ec2PublicIP=$(aws ec2 describe-instances --instance-ids ${awsEc2InstanceID} --query "Reservations[].Instances[].PublicDnsName")
	set_blj_prop ec2PublicIP $ec2PublicIP
}
