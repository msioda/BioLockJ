/**
 * @UNCC Fodor Lab
 * @author Anthony Fodor
 * @email anthony.fodor@gmail.com
 * @date Aug 9, 2018
 * @disclaimer This code is free software; you can redistribute it and/or modify it under the terms of the GNU General
 * Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any
 * later version, provided that any use properly credits the author. This program is distributed in the hope that it
 * will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details at http://www.gnu.org *
 */
package biolockj.util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;
import biolockj.Config;
import biolockj.Constants;
import biolockj.module.BioModule;
import biolockj.module.ScriptModule;

/**
 * S
 */
public class NextFlowUtil
{

	public static void buildNextFlowMain( final List<BioModule> modules ) throws Exception
	{
		writeNextFlowMainNF( getNextFlowLines( modules ) );
	}

	protected static List<String> getNextFlowLines( final List<BioModule> modules ) throws Exception
	{
		final List<String> lines = new ArrayList<>();
		lines.add( "// Nextflow main.nf generated by BioLockJ " + BioLockJUtil.getVersion() + " - Config: "
				+ Config.getConfigFilePath() );
		lines.add( "" );
		lines.add( Constants.AWS_EFS_DIR + " = \"" + Config.requireString( null, Constants.AWS_EFS_DIR ) + "\"" );
		lines.add( Constants.PROJECT_PIPELINE_DIR + " = \"" + getProp( Constants.AWS_EFS_DIR ) + File.separator
				+ Config.pipelineName() + "\"" );
		lines.add( "" );
		for( final BioModule module: modules )
		{
			lines.addAll( getProcessLines( module ) );
		}
		return lines;
	}


	protected static List<String> getProcessLines( final BioModule module ) throws Exception
	{
		final List<String> lines = new ArrayList<>();
		lines.add( PROCESS + " " + module + " {" );
		lines.add( getContainerLine( module ) );
		lines.add( getCpusLine( module ) );
		lines.add( getMemoryLine( module ) );
		lines.add( "" );
		lines.addAll( getInputLines( module ) );
		lines.add( "" );
		lines.addAll( getBashLines() );
		lines.add( "}" );
		lines.add( "" );
		return lines;
	}

	protected static void writeNextFlowMainNF( final List<String> lines ) throws Exception
	{
		final BufferedWriter writer = new BufferedWriter( new FileWriter( getFile() ) );
		try
		{
			boolean indent = false;
			for( final String line: lines )
			{
				if( line.endsWith( "}" ) )
				{
					indent = !indent;
				}
				writer.write( line + Constants.RETURN );
				if( line.endsWith( "{" ) )
				{
					indent = !indent;
				}
			}
		}
		finally
		{
			if( writer != null )
			{
				writer.close();
			}
		}
	}

	private static List<String> getBashLines() throws Exception
	{
		final List<String> lines = new ArrayList<>();
		lines.add( AWS_BASH_SCRIPT_DELIM );
		lines.add( BASH_SHEBANG );
		lines.add( "bash " + getProp( AWS_WORKER ) );
		lines.add( AWS_BASH_SCRIPT_DELIM );
		return lines;
	}

	private static String getContainerLine( final BioModule module ) throws Exception
	{
		return CONTAINER + " '" + JOB_DEF + "://" + Config.requireString( null, Constants.AWS_STACK ) + "_"
				+ DockerUtil.getImageName( module.getClass().getSimpleName() ) + "_"
				+ DockerUtil.getImageVersion( module ) + "'";
	}

	private static String getCpusLine( final BioModule module ) throws Exception
	{
		final Integer cpus = Config.requirePositiveInteger( module, ScriptModule.SCRIPT_NUM_THREADS );
		return CPUS + " " + cpus.toString();
	}

	private static File getFile() throws Exception
	{
		return new File( Config.pipelinePath() + File.separator + NEXT_FLOW_MAIN_NF );
	}

	private static List<String> getInputLines( final BioModule module ) throws Exception
	{
		final List<String> lines = new ArrayList<>();
		lines.add( AWS_PROC_INPUT );
		lines.add( "val " + AWS_WORKER + " from Channel.watchPath( '" + getProp( Constants.PROJECT_PIPELINE_DIR )
				+ File.separator + module.getModuleDir().getName() + File.separator + ScriptModule.SCRIPT_DIR
				+ "*.sh'" );
		return lines;
	}

	private static String getMemoryLine( final BioModule module ) throws Exception
	{
		return MEMORY + " '" + Config.requireString( module, Constants.AWS_RAM ) + "'";
	}

	private static String getProp( final String prop )
	{
		return "${" + prop + "}";
	}

	private static final String AWS_BASH_SCRIPT_DELIM = "\"\"\"";
	private static final String AWS_PROC_INPUT = "input:";
	private static final String AWS_WORKER = "worker";
	private static final String BASH_SHEBANG = "#!/bin/bash";
	private static final String CONTAINER = "container";
	private static final String CPUS = "cpus";
	private static final String JOB_DEF = "job-definition";
	private static final String MEMORY = "memory";
	private static final String NEXT_FLOW_MAIN_NF = "main.nf";
	private static final String PROCESS = "process";
}
